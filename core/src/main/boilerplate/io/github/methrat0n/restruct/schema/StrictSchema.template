package io.github.methrat0n.restruct.schema

import cats.data.NonEmptyList
import io.github.methrat0n.restruct.core.data.constraints.{Constraint, Constraints}
import io.github.methrat0n.restruct.core.data.schema.{FieldAlgebra, Path, StringStep}
import shapeless.{::, Generic, HNil}

import scala.language.higherKinds

sealed trait StrictSchema[A] extends Schema[A] {
  import io.github.methrat0n.restruct.schema.Syntax.string
  import io.github.methrat0n.restruct.schema.ProductSchema.ProductSchema1
  protected val typeField: RequiredField[String] = RequiredField(Path(NonEmptyList(StringStep("__type"), List.empty)), string, None)
  protected val typeSchema: String => Schema[String] = typeName => ProductSchema1(typeField, List(Constraints.EqualConstraint(typeName)))(new Generic[String] {
      override type Repr = String :: HNil

      override def to(t: String): Repr = t :: HNil

      override def from(r: Repr): String = r.head
    })
}

object StrictSchema {
  final case class StrictCoproductSchema1[Type, Product_1 <: Type](
      product1: Schema[Product_1],
      constraints: List[Constraint[Type]]
    )(implicit
      manifest1: Manifest[Product_1]
    ) extends StrictSchema[Type] {
      override def constraintedBy(constraint: Constraint[Type]): Schema[Type] =
        copy(constraints = constraints :+ constraint)

      import cats.implicits._
      override def bind[FORMAT[_]](algebra: FieldAlgebra[FORMAT]): FORMAT[Type] = {
        algebra.verifying((
          typeSchema(manifest1.runtimeClass.getSimpleName).bind(algebra),
          product1.bind(algebra)
        ).imapN((_, product) => product)(product => (manifest1.runtimeClass.getSimpleName, product))(algebra, algebra)
          .asInstanceOf[FORMAT[Type]], constraints)
      }
    }

  [2..5#final case class StrictCoproductSchema1[Type, [#Product_1 <: Type#]](
    [#product1: Schema[Product_1],#
    ]
    constraints: List[Constraint[Type]]
  )(implicit
    [#manifest1: Manifest[Product_1],#
    ]
  ) extends StrictSchema[Type] {
    override def constraintedBy(constraint: Constraint[Type]): Schema[Type] =
      copy(constraints = constraints :+ constraint)

    import cats.implicits._
    override def bind[FORMAT[_]](algebra: FieldAlgebra[FORMAT]): FORMAT[Type] = {
    [#
    val format1 = (
      typeSchema(manifest1.runtimeClass.getSimpleName).bind(algebra),
      product1.bind(algebra)
    ).imapN((_, product) => product)(product => (manifest1.runtimeClass.getSimpleName, product))(algebra, algebra)
    #
    ]

      algebra.verifying(algebra.imap(
        [#algebra.either(format1#], algebra.pure(())[# #)])
      )({
        case Left(product)  => product
        [2..#case [2..#Right(# ]Left(product)[2..# #)]) => product#
        ]
        case [#Right(# ]_: Unit[# #)]) => throw new RuntimeException("unable to find a matching schema") //TODO better error message
      })({
        [#case product: Product_1 => [2..#Right(# ]Left(product)[# #)]#
        ]
      }), constraints)
    }
  }
  #
  ]

  [..5#def apply[Type, [#Product_1 <: Type#]]([#schema1: Schema[Product_1]#])(implicit [#manifest1: Manifest[Product_1]#]): Schema[Type] = StrictCoproductSchema1([#schema1#], List.empty)#
  ]
}
package io.github.methrat0n.restruct.schema

import cats.{ Invariant, Semigroupal }
import io.github.methrat0n.restruct.core.Program
import io.github.methrat0n.restruct.core.data.constraints.Constraint
import io.github.methrat0n.restruct.core.data.schema.FieldAlgebra
import shapeless.{ ::, Generic, HNil }

import scala.language.higherKinds

trait SchemaConstructor[TYPE_CONSTRUCTOR[_]] {
  def of[A](schema: Schema[A]): Schema[TYPE_CONSTRUCTOR[A]]
}

sealed trait Schema[A] {
  def constraints: List[Constraint[A]]
  def constraintedBy(constraint: Constraint[A]): Schema[A]
  def bind[FORMAT[_]](algebra: FieldAlgebra[FORMAT]): FORMAT[A]
}

object Schema {

  final case class ProductSchema1[A, Field_1](
    field1: Field[Field_1],
    constraints: List[Constraint[A]]
  )(implicit generic: Generic.Aux[A, Field_1 :: HNil]) extends Schema[A] {
    def bind[FORMAT[_]](algebra: FieldAlgebra[FORMAT]): FORMAT[A] =
      field1.program.imap(_ :: HNil)(_.head)
        .imap(generic.from)(generic.to).run(algebra)

    override def constraintedBy(constraint: Constraint[A]): Schema[A] =
      copy(constraints = constraints :+ constraint)
  }

[2..50#
  final case class ProductSchema1[A, [#Field_1#]](
    [#field1: Field[Field_1],#
    ]
    constraints: List[Constraint[A]]
  )(implicit
    semigroupal: Semigroupal[Program[FieldAlgebra, ?]],
    invariant: Invariant[Program[FieldAlgebra, ?]],
    generic: Generic.Aux[A, [#Field_1# :: ] :: HNil]
  ) extends Schema[A] {
    def bind[FORMAT[_]](algebra: FieldAlgebra[FORMAT]): FORMAT[A] =
      field##1.program
        .product(field##2.program)
        [3..#.product(field1.program)#
        ]
        .imap { case [# #(]field##1, [2..#field1#), ]) => [#field1# :: ] :: HNil }(hlist => [# #(]hlist.head, [2..#hlist.[2..#tail#.].head#), ]))
        .imap(generic.from)(generic.to)
        .run(algebra)

    override def constraintedBy(constraint: Constraint[A]): Schema[A] =
      copy(constraints = constraints :+ constraint)
  }
#
]

  trait TypedSchema[A] extends Schema[A] {
    def bind[FORMAT[_]](algebra: FieldAlgebra[FORMAT]): FORMAT[A] =
      program.run(algebra)

    def program: Program[FieldAlgebra, A]

    override def constraintedBy(constraint: Constraint[A]): Schema[A] = TypedSchema(program, constraints :+ constraint)
  }

  object TypedSchema {
    def apply[A](prgram: Program[FieldAlgebra, A], constaints: List[Constraint[A]]): TypedSchema[A] = new TypedSchema[A]() {
      override def program: Program[FieldAlgebra, A] = prgram
      override def constraints: List[Constraint[A]] = constaints
    }
  }

  [..50#def apply[Type <: Product, [#Field_1#]]([#field1: Field[Field_1]#])(implicit generic: Generic.Aux[Type,[#Field_1# :: ] :: HNil]): Schema[Type] = new ProductSchema1[Type, [#Field_1#]]([#field1#], List.empty)#
  ]

    def apply[Type](program: Program[FieldAlgebra, Type]): Schema[Type] = TypedSchema(program, List.empty)
}
